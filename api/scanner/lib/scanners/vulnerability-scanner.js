const axios = require('axios');
const { EventEmitter } = require('events');
const crypto = require('crypto');
const net = require('net');
const tls = require('tls');
const PortScanner = require('./port-scanner');
const logger = require('../utils/logger');
const validator = require('../utils/validator');
const patchManager = require('../utils/version-detection/patch-manager');
const versionAnalyzer = require('../utils/version-detection/version-analyzer');
const osPatchDetector = require('../utils/version-detection/os-patch-detector');
const frameworkDetector = require('../utils/version-detection/framework-detector');

/**
 * VulnerabilityScanner class for detecting common vulnerabilities
 */
class VulnerabilityScanner extends EventEmitter {
  /**
   * Create a new vulnerability scanner instance
   * @param {Object} options - Scanner options
   * @param {number} options.timeout - Timeout in milliseconds
   */
  constructor(options = {}) {
    super();
    this.timeout = options.timeout || 10000;
    this.scanInProgress = false;
    this.aborted = false;
    
    // Define vulnerability checks
    this.vulnerabilityChecks = {
      'ssl-tls': this.checkSslTls.bind(this),
      'http-headers': this.checkHttpHeaders.bind(this),
      'open-ports': this.checkOpenPorts.bind(this),
      'default-credentials': this.checkDefaultCredentials.bind(this),
      'ssh-security': this.checkSshSecurity.bind(this),
      'smtp-security': this.checkSmtpSecurity.bind(this),
      'ftp-security': this.checkFtpSecurity.bind(this),
      'smb-security': this.checkSmbSecurity.bind(this),
      'db-security': this.checkDatabaseSecurity.bind(this),
      'patch-detection': this.checkPatchStatus.bind(this)
    };
  }

  /**
   * Scan for vulnerabilities on a target
   * @param {string} target - Target to scan
   * @param {Object} options - Scan options
   * @param {Array<number>} options.ports - Ports to scan
   * @param {string|Array<string>} options.checks - Specific checks to run, 'all' for all checks
   * @returns {Promise<Object>} - Vulnerability scan results
   */
  async scan(target, options = {}) {
    if (this.scanInProgress) {
      throw new Error('A scan is already in progress');
    }

    if (!validator.isValidTarget(target)) {
      throw new Error(`Invalid target: ${target}`);
    }

    this.scanInProgress = true;
    this.aborted = false;
    
    logger.scan.start('vulnerability', target);
    
    try {
      const results = {
        target,
        timestamp: new Date().toISOString(),
        vulnerabilities: [],
        openPorts: []
      };
      
      // Determine which checks to run
      let checksToRun = [];
      if (!options.checks || options.checks === 'all') {
        checksToRun = Object.keys(this.vulnerabilityChecks);
      } else if (Array.isArray(options.checks)) {
        checksToRun = options.checks.filter(check => this.vulnerabilityChecks[check]);
      } else if (typeof options.checks === 'string') {
        checksToRun = options.checks.split(',').map(c => c.trim()).filter(check => this.vulnerabilityChecks[check]);
      }
      
      if (checksToRun.length === 0) {
        logger.warn('No valid vulnerability checks specified');
        this.scanInProgress = false;
        return results;
      }
      
      // First, scan for open ports
      let ports = [];
      if (options.ports) {
        // If we have ports defined, parse them
        ports = Array.isArray(options.ports) 
          ? options.ports 
          : validator.parsePortsString(options.ports) || [];
      } else {
        // Default to common ports if no specific ports are provided
        ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 445, 3306, 5432, 8080, 8443];
      }
      
      if (ports && ports.length > 0) {
        logger.info(`Scanning ${target} for open ports as part of vulnerability check`);
        const portScanner = new PortScanner({ timeout: Math.min(5000, this.timeout) });
        const openPorts = await portScanner.scan(target, ports);
        results.openPorts = openPorts;
      }
      
      // Run each vulnerability check
      let completed = 0;
      const total = checksToRun.length;
      
      for (const checkName of checksToRun) {
        if (this.aborted) {
          break;
        }
        
        logger.debug(`Running vulnerability check: ${checkName}`);
        this.emit('progress', {
          phase: 'vulnerability-check',
          check: checkName,
          current: completed + 1,
          total
        });
        
        try {
          const checkFn = this.vulnerabilityChecks[checkName];
          const checkResults = await checkFn(target, results.openPorts, options);
          
          if (checkResults && checkResults.length > 0) {
            results.vulnerabilities.push(...checkResults);
          }
        } catch (error) {
          logger.error(`Error in vulnerability check ${checkName}: ${error.message}`);
        }
        
        completed++;
      }
      
      // Calculate vulnerability statistics
      results.stats = {
        total: results.vulnerabilities.length,
        high: results.vulnerabilities.filter(v => v.severity === 'high').length,
        medium: results.vulnerabilities.filter(v => v.severity === 'medium').length,
        low: results.vulnerabilities.filter(v => v.severity === 'low').length,
        info: results.vulnerabilities.filter(v => v.severity === 'info').length
      };
      
      logger.scan.complete('vulnerability', target, results);
      this.scanInProgress = false;
      return results;
    } catch (error) {
      this.scanInProgress = false;
      logger.error(`Error scanning vulnerabilities on ${target}: ${error.message}`);
      throw error;
    }
  }

  /**
   * Check for SSL/TLS vulnerabilities
   * @param {string} target - Target to check
   * @param {Array} openPorts - Previously discovered open ports
   * @returns {Promise<Array>} - Vulnerabilities found
   */
  async checkSslTls(target, openPorts = []) {
    const vulnerabilities = [];
    
    // Determine which ports to check for SSL/TLS
    const sslPorts = openPorts
      .filter(p => [443, 8443, 465, 993, 995].includes(p.port))
      .map(p => p.port);
    
    // Add default HTTPS port if we have no information
    if (sslPorts.length === 0) {
      sslPorts.push(443);
    }
    
    for (const port of sslPorts) {
      if (this.aborted) break;
      
      try {
        const cert = await this.getCertificateInfo(target, port);
        
        if (!cert) {
          continue;
        }
        
        // Check certificate expiration
        if (cert.validTo) {
          const expiryDate = new Date(cert.validTo);
          const now = new Date();
          const daysUntilExpiry = Math.floor((expiryDate - now) / (1000 * 60 * 60 * 24));
          
          if (daysUntilExpiry < 0) {
            vulnerabilities.push({
              id: `ssl-expired-${port}`,
              name: `Expired SSL Certificate`,
              description: `The SSL certificate on port ${port} expired ${Math.abs(daysUntilExpiry)} days ago.`,
              port,
              severity: 'high',
              details: {
                expiryDate: cert.validTo,
                subject: cert.subject
              }
            });
          } else if (daysUntilExpiry < 14) {
            vulnerabilities.push({
              id: `ssl-expiring-${port}`,
              name: `Expiring SSL Certificate`,
              description: `The SSL certificate on port ${port} will expire in ${daysUntilExpiry} days.`,
              port,
              severity: 'medium',
              details: {
                expiryDate: cert.validTo,
                subject: cert.subject
              }
            });
          }
        }
        
        // Check for weak signature algorithms
        if (cert.signatureAlgorithm && (
            cert.signatureAlgorithm.includes('md5') || 
            cert.signatureAlgorithm.includes('sha1')
        )) {
          vulnerabilities.push({
            id: `ssl-weak-signature-${port}`,
            name: `Weak SSL Certificate Signature Algorithm`,
            description: `The SSL certificate on port ${port} uses a weak signature algorithm (${cert.signatureAlgorithm}).`,
            port,
            severity: 'medium',
            details: {
              signatureAlgorithm: cert.signatureAlgorithm,
              subject: cert.subject
            }
          });
        }
        
        // Check supported protocols
        const supportedProtocols = await this.checkSupportedSslProtocols(target, port);
        
        if (supportedProtocols.includes('SSLv3')) {
          vulnerabilities.push({
            id: `ssl-protocol-sslv3-${port}`,
            name: `SSLv3 Protocol Support`,
            description: `The server on port ${port} supports the insecure SSLv3 protocol, which is vulnerable to the POODLE attack.`,
            port,
            severity: 'high',
            details: {
              protocols: supportedProtocols
            }
          });
        }
        
        if (supportedProtocols.includes('TLSv1.0')) {
          vulnerabilities.push({
            id: `ssl-protocol-tlsv1.0-${port}`,
            name: `TLSv1.0 Protocol Support`,
            description: `The server on port ${port} supports the outdated TLSv1.0 protocol, which has known vulnerabilities.`,
            port,
            severity: 'medium',
            details: {
              protocols: supportedProtocols
            }
          });
        }
        
        // More SSL/TLS checks could be added here
        
      } catch (error) {
        logger.debug(`SSL/TLS check error on ${target}:${port}: ${error.message}`);
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Get SSL/TLS certificate information
   * @param {string} host - Host to connect to
   * @param {number} port - Port to connect to
   * @returns {Promise<Object>} - Certificate information
   */
  getCertificateInfo(host, port) {
    return new Promise((resolve, reject) => {
      const socket = tls.connect({
        host,
        port,
        rejectUnauthorized: false, // We want to get info even for invalid certs
        timeout: this.timeout
      }, () => {
        try {
          const cert = socket.getPeerCertificate(true);
          
          // Check if certificate is actually present
          if (Object.keys(cert).length < 1) {
            socket.end();
            resolve(null);
            return;
          }
          
          // Format certificate data
          const certInfo = {
            subject: cert.subject,
            issuer: cert.issuer,
            validFrom: cert.valid_from,
            validTo: cert.valid_to,
            fingerprint: cert.fingerprint,
            serialNumber: cert.serialNumber,
            signatureAlgorithm: cert.signatureAlgorithm,
          };
          
          socket.end();
          resolve(certInfo);
        } catch (error) {
          socket.end();
          reject(error);
        }
      });
      
      socket.on('timeout', () => {
        socket.end();
        reject(new Error('Connection timeout'));
      });
      
      socket.on('error', (error) => {
        reject(error);
      });
    });
  }

  /**
   * Check which SSL/TLS protocols are supported by a server
   * @param {string} host - Host to connect to
   * @param {number} port - Port to connect to
   * @returns {Promise<Array<string>>} - Supported protocols
   */
  async checkSupportedSslProtocols(host, port) {
    const protocols = ['SSLv3', 'TLSv1.0', 'TLSv1.1', 'TLSv1.2', 'TLSv1.3'];
    const supported = [];
    
    for (const protocol of protocols) {
      try {
        await new Promise((resolve, reject) => {
          const socket = tls.connect({
            host,
            port,
            minVersion: protocol,
            maxVersion: protocol,
            rejectUnauthorized: false,
            timeout: this.timeout / 2
          }, () => {
            supported.push(protocol);
            socket.end();
            resolve();
          });
          
          socket.on('error', () => {
            socket.destroy();
            resolve(); // Not supported, no error needed
          });
          
          socket.on('timeout', () => {
            socket.destroy();
            resolve(); // Timeout, consider protocol not supported
          });
        });
      } catch (error) {
        // Ignore failures - means protocol is not supported
      }
    }
    
    return supported;
  }

  /**
   * Check for HTTP header security issues
   * @param {string} target - Target to check
   * @param {Array} openPorts - Previously discovered open ports
   * @returns {Promise<Array>} - Vulnerabilities found
   */
  async checkHttpHeaders(target, openPorts = []) {
    const vulnerabilities = [];
    
    // Determine which ports to check for HTTP services
    let httpPorts = openPorts
      .filter(p => [80, 443, 8080, 8443].includes(p.port))
      .map(p => p.port);
    
    // If no ports from scan, check default HTTP ports
    if (httpPorts.length === 0) {
      httpPorts = [80, 443];
    }
    
    for (const port of httpPorts) {
      if (this.aborted) break;
      
      const protocol = (port === 443 || port === 8443) ? 'https' : 'http';
      const url = `${protocol}://${target}:${port}/`;
      
      try {
        const response = await axios.get(url, {
          timeout: this.timeout,
          validateStatus: () => true, // Accept any status code
          maxRedirects: 0, // Don't follow redirects
          headers: {
            'User-Agent': 'Mozilla/5.0 VulScan/1.0'
          }
        });
        
        const headers = response.headers;
        
        // Check for missing security headers
        const securityHeaders = {
          'strict-transport-security': {
            missing: 'Missing HSTS Header',
            description: 'The HTTP Strict Transport Security header is not set. This header helps protect against protocol downgrade attacks and cookie hijacking.',
            severity: 'medium'
          },
          'x-content-type-options': {
            missing: 'Missing X-Content-Type-Options Header',
            description: 'The X-Content-Type-Options header is not set to "nosniff". This header prevents browsers from interpreting files as a different MIME type.',
            severity: 'low'
          },
          'x-frame-options': {
            missing: 'Missing X-Frame-Options Header',
            description: 'The X-Frame-Options header is not set. This header prevents clickjacking attacks by not allowing the page to be embedded into frames.',
            severity: 'medium'
          },
          'content-security-policy': {
            missing: 'Missing Content-Security-Policy Header',
            description: 'The Content-Security-Policy header is not set. This header helps prevent Cross-Site Scripting (XSS) and other code injection attacks.',
            severity: 'medium'
          },
          'x-xss-protection': {
            missing: 'Missing X-XSS-Protection Header',
            description: 'The X-XSS-Protection header is not set. This header enables the browser\'s built-in XSS filter.',
            severity: 'low'
          }
        };
        
        for (const [header, info] of Object.entries(securityHeaders)) {
          if (!(header.toLowerCase() in headers)) {
            vulnerabilities.push({
              id: `missing-header-${header}-${port}`,
              name: info.missing,
              description: info.description,
              port,
              severity: info.severity,
              details: {
                url,
                header
              }
            });
          }
        }
        
        // Check for insecure cookies
        if ('set-cookie' in headers) {
          const cookies = Array.isArray(headers['set-cookie']) 
            ? headers['set-cookie'] 
            : [headers['set-cookie']];
          
          for (const cookie of cookies) {
            if (!cookie.includes('secure') && (protocol === 'https')) {
              vulnerabilities.push({
                id: `insecure-cookie-${port}`,
                name: 'Insecure Cookie',
                description: 'A cookie was set without the Secure flag, which means it can be transmitted over unencrypted connections.',
                port,
                severity: 'medium',
                details: {
                  url,
                  cookie: cookie.split(';')[0] // Only show cookie name, not value
                }
              });
            }
            
            if (!cookie.includes('httponly')) {
              vulnerabilities.push({
                id: `httponly-cookie-${port}`,
                name: 'Missing HttpOnly Cookie Flag',
                description: 'A cookie was set without the HttpOnly flag, which means it can be accessed by JavaScript.',
                port,
                severity: 'medium',
                details: {
                  url,
                  cookie: cookie.split(';')[0] // Only show cookie name, not value
                }
              });
            }
          }
        }
        
        // Check for server version disclosure
        if ('server' in headers) {
          const serverHeader = headers['server'];
          if (/\d+\.\d+/.test(serverHeader)) { // Simple version number check
            vulnerabilities.push({
              id: `server-version-disclosure-${port}`,
              name: 'Server Version Disclosure',
              description: 'The server header discloses version information, which could help attackers target specific vulnerabilities.',
              port,
              severity: 'low',
              details: {
                url,
                server: serverHeader
              }
            });
          }
        }
        
      } catch (error) {
        logger.debug(`HTTP header check error on ${url}: ${error.message}`);
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Check for risky open ports
   * @param {string} target - Target to check
   * @param {Array} openPorts - Previously discovered open ports
   * @returns {Promise<Array>} - Vulnerabilities found
   */
  async checkOpenPorts(target, openPorts = []) {
    const vulnerabilities = [];
    
    // Define risky ports and their descriptions
    const riskyPorts = {
      21: { name: 'FTP', severity: 'medium', description: 'FTP service found. FTP transfers data in cleartext and may allow anonymous access.' },
      23: { name: 'Telnet', severity: 'high', description: 'Telnet service found. Telnet transfers data including credentials in cleartext.' },
      25: { name: 'SMTP', severity: 'low', description: 'SMTP service found. Check if it allows relaying or is vulnerable to user enumeration.' },
      53: { name: 'DNS', severity: 'low', description: 'DNS service found. Check if it allows zone transfers or recursive queries.' },
      139: { name: 'NetBIOS', severity: 'medium', description: 'NetBIOS service found. May provide system information and shares.' },
      445: { name: 'SMB', severity: 'medium', description: 'SMB service found. Check for vulnerable versions.' },
      1433: { name: 'MSSQL', severity: 'medium', description: 'Microsoft SQL Server found. Check for weak authentication.' },
      1521: { name: 'Oracle DB', severity: 'medium', description: 'Oracle database service found. Check for default credentials.' },
      3306: { name: 'MySQL', severity: 'medium', description: 'MySQL database service found. Check for weak authentication.' },
      3389: { name: 'RDP', severity: 'medium', description: 'Remote Desktop service found. Check for outdated versions.' },
      5432: { name: 'PostgreSQL', severity: 'medium', description: 'PostgreSQL database service found. Check for weak authentication.' },
      5900: { name: 'VNC', severity: 'medium', description: 'VNC service found. Check for weak authentication.' },
      6379: { name: 'Redis', severity: 'high', description: 'Redis service found. Check if it is protected by authentication.' },
      8080: { name: 'HTTP Proxy', severity: 'low', description: 'Possible HTTP proxy found. Check if it allows open proxy.' },
      9200: { name: 'Elasticsearch', severity: 'high', description: 'Elasticsearch service found. Check if it requires authentication.' },
      27017: { name: 'MongoDB', severity: 'high', description: 'MongoDB service found. Check if it requires authentication.' }
    };
    
    // Check for risky open ports
    for (const portInfo of openPorts) {
      const port = portInfo.port;
      
      if (port in riskyPorts) {
        const risk = riskyPorts[port];
        
        vulnerabilities.push({
          id: `open-port-${port}`,
          name: `Open ${risk.name} Port`,
          description: risk.description,
          port,
          severity: risk.severity,
          details: {
            service: portInfo.service
          }
        });
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Check for default/weak credentials
   * @param {string} target - Target to check
   * @param {Array} openPorts - Previously discovered open ports
   * @returns {Promise<Array>} - Vulnerabilities found
   */
  async checkDefaultCredentials(target, openPorts = []) {
    // This is a non-intrusive scan, so we'll only check for common web interfaces
    // and report them as potential issues without actually testing credentials
    
    const vulnerabilities = [];
    
    // Define common web admin interfaces
    const webInterfaces = [
      { path: '/login', name: 'Login Page' },
      { path: '/admin', name: 'Admin Login Page' },
      { path: '/wp-login.php', name: 'WordPress Login' },
      { path: '/administrator', name: 'Joomla Login' },
      { path: '/phpmyadmin', name: 'phpMyAdmin' },
      { path: '/manager/html', name: 'Tomcat Manager' },
      { path: '/jenkins', name: 'Jenkins' },
      { path: '/dashboard', name: 'Dashboard Login' }
    ];
    
    // Determine which ports to check for HTTP services
    let httpPorts = openPorts
      .filter(p => [80, 443, 8080, 8443].includes(p.port))
      .map(p => p.port);
    
    // If no ports from scan, check default HTTP ports
    if (httpPorts.length === 0) {
      httpPorts = [80, 443];
    }
    
    for (const port of httpPorts) {
      if (this.aborted) break;
      
      const protocol = (port === 443 || port === 8443) ? 'https' : 'http';
      
      for (const iface of webInterfaces) {
        const url = `${protocol}://${target}:${port}${iface.path}`;
        
        try {
          const response = await axios.get(url, {
            timeout: this.timeout,
            validateStatus: () => true, // Accept any status code
            maxRedirects: 0 // Don't follow redirects
          });
          
          // Check if the response looks like a login page
          const body = response.data.toString().toLowerCase();
          
          if (
            (response.status === 200 || response.status === 401) &&
            (body.includes('login') || body.includes('password') || body.includes('username') || body.includes('sign in'))
          ) {
            vulnerabilities.push({
              id: `login-interface-${port}-${iface.path.replace(/\//g, '-')}`,
              name: `${iface.name} Found`,
              description: `A login interface was found at ${url}. Check for default credentials or brute force protection.`,
              port,
              severity: 'medium',
              details: {
                url,
                status: response.status,
                interface: iface.name
              }
            });
          }
        } catch (error) {
          // Ignore connection errors
        }
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Check for SSH security issues
   * @param {string} target - Target to check
   * @param {Array} openPorts - Previously discovered open ports
   * @returns {Promise<Array>} - Vulnerabilities found
   */
  async checkSshSecurity(target, openPorts = []) {
    const vulnerabilities = [];
    
    // Find SSH ports
    const sshPorts = openPorts
      .filter(p => p.port === 22 || p.service === 'SSH')
      .map(p => p.port);
    
    // If no SSH ports found, check default port
    if (sshPorts.length === 0) {
      sshPorts.push(22);
    }
    
    for (const port of sshPorts) {
      if (this.aborted) break;
      
      try {
        // Create a socket connection to get the SSH banner
        const socket = new net.Socket();
        
        const banner = await new Promise((resolve, reject) => {
          let data = '';
          
          socket.setTimeout(this.timeout);
          
          socket.on('data', (chunk) => {
            data += chunk.toString();
            socket.end();
          });
          
          socket.on('timeout', () => {
            socket.destroy();
            reject(new Error('Connection timeout'));
          });
          
          socket.on('error', (err) => {
            reject(err);
          });
          
          socket.on('close', () => {
            resolve(data);
          });
          
          socket.connect(port, target);
        });
        
        // Check SSH protocol version
        if (banner.includes('SSH-1.') || banner.includes('SSH-1.99')) {
          vulnerabilities.push({
            id: `ssh-old-protocol-${port}`,
            name: 'Obsolete SSH Protocol Version',
            description: 'The server is using an obsolete version of the SSH protocol (SSHv1), which has known security issues.',
            port,
            severity: 'high',
            details: {
              banner: banner.trim()
            }
          });
        }
        
        // Check for old SSH software versions
        if (banner.includes('OpenSSH')) {
          const versionMatch = banner.match(/OpenSSH_(\d+\.\d+)/);
          if (versionMatch) {
            const version = parseFloat(versionMatch[1]);
            if (version < 7.0) {
              vulnerabilities.push({
                id: `ssh-old-version-${port}`,
                name: 'Outdated SSH Server Version',
                description: `The server is running an outdated version of OpenSSH (${versionMatch[0]}), which may contain known vulnerabilities.`,
                port,
                severity: 'medium',
                details: {
                  banner: banner.trim(),
                  version: versionMatch[0]
                }
              });
            }
          }
        }
      } catch (error) {
        logger.debug(`SSH security check error on ${target}:${port}: ${error.message}`);
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Check for SMTP security issues
   * @param {string} target - Target to check
   * @param {Array} openPorts - Previously discovered open ports
   * @returns {Promise<Array>} - Vulnerabilities found
   */
  async checkSmtpSecurity(target, openPorts = []) {
    const vulnerabilities = [];
    
    // Find SMTP ports
    const smtpPorts = openPorts
      .filter(p => [25, 465, 587].includes(p.port) || p.service === 'SMTP')
      .map(p => p.port);
    
    // If no SMTP ports found, check default port
    if (smtpPorts.length === 0) {
      smtpPorts.push(25);
    }
    
    for (const port of smtpPorts) {
      if (this.aborted) break;
      
      try {
        // Create a socket connection to get the SMTP banner
        const socket = new net.Socket();
        
        const banner = await new Promise((resolve, reject) => {
          let data = '';
          
          socket.setTimeout(this.timeout);
          
          socket.on('data', (chunk) => {
            data += chunk.toString();
            socket.end();
          });
          
          socket.on('timeout', () => {
            socket.destroy();
            reject(new Error('Connection timeout'));
          });
          
          socket.on('error', (err) => {
            reject(err);
          });
          
          socket.on('close', () => {
            resolve(data);
          });
          
          socket.connect(port, target);
        });
        
        // Check if SMTP server reveals version information
        if (banner.match(/\d+\.\d+\.\d+/)) {
          vulnerabilities.push({
            id: `smtp-version-disclosure-${port}`,
            name: 'SMTP Version Disclosure',
            description: 'The SMTP server reveals version information, which could help attackers target specific vulnerabilities.',
            port,
            severity: 'low',
            details: {
              banner: banner.trim()
            }
          });
        }
        
        // Check for open relay (non-intrusive check, just report the presence of SMTP)
        if (port === 25) {
          vulnerabilities.push({
            id: `smtp-open-relay-check-${port}`,
            name: 'SMTP Open Relay Check Recommended',
            description: 'An SMTP server is running. This server should be tested for open relay configuration, which could allow spammers to send emails through it.',
            port,
            severity: 'info',
            details: {
              recommendation: 'Test the server for open relay configuration with proper authorization.'
            }
          });
        }
      } catch (error) {
        logger.debug(`SMTP security check error on ${target}:${port}: ${error.message}`);
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Check for FTP security issues
   * @param {string} target - Target to check
   * @param {Array} openPorts - Previously discovered open ports
   * @returns {Promise<Array>} - Vulnerabilities found
   */
  async checkFtpSecurity(target, openPorts = []) {
    const vulnerabilities = [];
    
    // Find FTP ports
    const ftpPorts = openPorts
      .filter(p => p.port === 21 || p.service === 'FTP')
      .map(p => p.port);
    
    // If no FTP ports found, check default port
    if (ftpPorts.length === 0) {
      ftpPorts.push(21);
    }
    
    for (const port of ftpPorts) {
      if (this.aborted) break;
      
      try {
        // Create a socket connection to get the FTP banner
        const socket = new net.Socket();
        
        const banner = await new Promise((resolve, reject) => {
          let data = '';
          
          socket.setTimeout(this.timeout);
          
          socket.on('data', (chunk) => {
            data += chunk.toString();
            socket.end();
          });
          
          socket.on('timeout', () => {
            socket.destroy();
            reject(new Error('Connection timeout'));
          });
          
          socket.on('error', (err) => {
            reject(err);
          });
          
          socket.on('close', () => {
            resolve(data);
          });
          
          socket.connect(port, target);
        });
        
        // FTP is inherently insecure (cleartext)
        vulnerabilities.push({
          id: `ftp-cleartext-${port}`,
          name: 'Insecure FTP Service',
          description: 'FTP service transmits data and credentials in cleartext, which can be intercepted by attackers.',
          port,
          severity: 'medium',
          details: {
            recommendation: 'Replace with SFTP or FTPS for secure file transfers.'
          }
        });
        
        // Check for anonymous FTP access (report only as a recommendation to check)
        vulnerabilities.push({
          id: `ftp-anonymous-check-${port}`,
          name: 'Anonymous FTP Access Check Recommended',
          description: 'FTP server found. This server should be checked for anonymous access, which could expose sensitive files.',
          port,
          severity: 'info',
          details: {
            banner: banner.trim(),
            recommendation: 'Test the server for anonymous FTP access with user "anonymous".'
          }
        });
        
        // Check if FTP server reveals version information
        if (banner.match(/\d+\.\d+\.\d+/)) {
          vulnerabilities.push({
            id: `ftp-version-disclosure-${port}`,
            name: 'FTP Version Disclosure',
            description: 'The FTP server reveals version information, which could help attackers target specific vulnerabilities.',
            port,
            severity: 'low',
            details: {
              banner: banner.trim()
            }
          });
        }
      } catch (error) {
        logger.debug(`FTP security check error on ${target}:${port}: ${error.message}`);
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Check for SMB security issues
   * @param {string} target - Target to check
   * @param {Array} openPorts - Previously discovered open ports
   * @returns {Promise<Array>} - Vulnerabilities found
   */
  async checkSmbSecurity(target, openPorts = []) {
    const vulnerabilities = [];
    
    // Find SMB ports
    const smbPorts = openPorts
      .filter(p => [139, 445].includes(p.port) || p.service === 'SMB')
      .map(p => p.port);
    
    // If no SMB ports found, don't check (not commonly open if not in use)
    if (smbPorts.length === 0) {
      return vulnerabilities;
    }
    
    // Since checking SMB would require more intrusive testing,
    // just report the presence of SMB services and recommend further checks
    for (const port of smbPorts) {
      vulnerabilities.push({
        id: `smb-security-check-${port}`,
        name: 'SMB Service Security Check Recommended',
        description: 'An SMB service was found. SMB has had numerous critical vulnerabilities in the past (e.g., EternalBlue).',
        port,
        severity: 'medium',
        details: {
          recommendation: 'Check for outdated SMB versions (SMBv1, SMBv2) and verify access controls.'
        }
      });
    }
    
    return vulnerabilities;
  }

  /**
   * Check for database security issues
   * @param {string} target - Target to check
   * @param {Array} openPorts - Previously discovered open ports
   * @returns {Promise<Array>} - Vulnerabilities found
   */
  async checkDatabaseSecurity(target, openPorts = []) {
    const vulnerabilities = [];
    
    // Database port mappings
    const dbPorts = {
      1433: { name: 'MS SQL Server', severity: 'high' },
      1521: { name: 'Oracle Database', severity: 'high' },
      3306: { name: 'MySQL/MariaDB', severity: 'high' },
      5432: { name: 'PostgreSQL', severity: 'high' },
      6379: { name: 'Redis', severity: 'critical' },
      27017: { name: 'MongoDB', severity: 'critical' }
    };
    
    // Check for database ports
    for (const portInfo of openPorts) {
      const port = portInfo.port;
      
      if (port in dbPorts) {
        const db = dbPorts[port];
        
        vulnerabilities.push({
          id: `database-exposure-${port}`,
          name: `Exposed ${db.name} Database`,
          description: `The ${db.name} database port is exposed to the network. Database ports should not be publicly accessible.`,
          port,
          severity: db.severity,
          details: {
            recommendation: 'Restrict access to this database port using a firewall or security groups. Use SSL/TLS for connections if possible.'
          }
        });
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Check for outdated software and missing patches
   * @param {string} target - Target to check
   * @param {Array} openPorts - Previously discovered open ports
   * @param {Object} options - Options for the patch check
   * @returns {Promise<Array>} - Vulnerabilities found
   */
  async checkPatchStatus(target, openPorts = [], options = {}) {
    const vulnerabilities = [];
    logger.info(`Checking patch status for ${target}`);
    
    try {
      // Determine web server port to check
      const webPorts = openPorts
        .filter(p => [80, 443, 8080, 8443].includes(p.port))
        .map(p => p.port);
      
      // Default to standard ports if none found
      const httpPort = webPorts.find(p => p === 80 || p === 8080) || 80;
      const httpsPort = webPorts.find(p => p === 443 || p === 8443) || 443;
      
      // Prepare scan options
      const scanOptions = {
        timeout: this.timeout,
        baseUrl: `http://${target}:${httpPort}/`,
        sshClient: options.sshClient || null,
        userAgent: 'Mozilla/5.0 VulScan/1.0'
      };
      
      // Try to get HTTP server info
      try {
        const response = await axios.get(scanOptions.baseUrl, {
          timeout: this.timeout,
          validateStatus: () => true,
          maxRedirects: 0,
          headers: {
            'User-Agent': scanOptions.userAgent
          }
        });
        
        if (response.status < 400) {
          scanOptions.serverInfo = {
            headers: response.headers
          };
        }
      } catch (error) {
        logger.debug(`Could not connect to HTTP server on port ${httpPort}: ${error.message}`);
        
        // Try HTTPS instead
        try {
          const httpsResponse = await axios.get(`https://${target}:${httpsPort}/`, {
            timeout: this.timeout,
            validateStatus: () => true,
            maxRedirects: 0,
            headers: {
              'User-Agent': scanOptions.userAgent
            }
          });
          
          if (httpsResponse.status < 400) {
            scanOptions.serverInfo = {
              headers: httpsResponse.headers
            };
            scanOptions.baseUrl = `https://${target}:${httpsPort}/`;
          }
        } catch (httpsError) {
          logger.debug(`Could not connect to HTTPS server on port ${httpsPort}: ${httpsError.message}`);
        }
      }
      
      // Perform the patch assessment
      const patchResults = await patchManager.performPatchAssessment(target, scanOptions);
      
      // Convert the patch assessment results to vulnerability format
      if (patchResults && patchResults.vulnerabilities) {
        for (const vuln of patchResults.vulnerabilities) {
          vulnerabilities.push({
            id: vuln.id || `patch-${vulnerabilities.length + 1}`,
            name: `Outdated ${vuln.componentType}: ${vuln.component}`,
            description: vuln.description,
            severity: vuln.severity,
            details: {
              component: vuln.component,
              componentType: vuln.componentType,
              remediation: vuln.remediation,
              evidence: vuln.evidence
            }
          });
        }
      }
      
      // Add warnings for outdated components
      if (patchResults.summary && patchResults.summary.outdatedComponents > 0) {
        vulnerabilities.push({
          id: 'outdated-components',
          name: 'Outdated Software Components',
          description: `${patchResults.summary.outdatedComponents} outdated software components were detected.`,
          severity: 'medium',
          details: {
            outdatedCount: patchResults.summary.outdatedComponents,
            eolCount: patchResults.summary.eolComponents,
            components: [
              patchResults.webServer && patchResults.webServer.isOutdated ? 
                { name: patchResults.webServer.software, version: patchResults.webServer.version, latestVersion: patchResults.webServer.latestVersion } : null,
              patchResults.database && patchResults.database.isOutdated ?
                { name: patchResults.database.software, version: patchResults.database.version, latestVersion: patchResults.database.latestVersion } : null,
              ...patchResults.frameworks.filter(f => f.isOutdated).map(f => ({
                name: f.framework,
                version: f.version,
                latestVersion: f.latestVersion
              }))
            ].filter(Boolean)
          }
        });
      }
      
      // Add critical warning for EOL components
      if (patchResults.summary && patchResults.summary.eolComponents > 0) {
        vulnerabilities.push({
          id: 'eol-components',
          name: 'End-of-Life Software Components',
          description: `${patchResults.summary.eolComponents} end-of-life software components were detected. These components no longer receive security updates.`,
          severity: 'critical',
          details: {
            eolCount: patchResults.summary.eolComponents,
            components: [
              patchResults.webServer && patchResults.webServer.eol ? 
                { name: patchResults.webServer.software, version: patchResults.webServer.version } : null,
              patchResults.database && patchResults.database.eol ?
                { name: patchResults.database.software, version: patchResults.database.version } : null,
              ...patchResults.frameworks.filter(f => f.eol).map(f => ({
                name: f.framework,
                version: f.version
              }))
            ].filter(Boolean)
          }
        });
      }
      
    } catch (error) {
      logger.error(`Error checking patch status: ${error.message}`);
    }
    
    return vulnerabilities;
  }

  /**
   * Stop an ongoing scan
   */
  abort() {
    if (this.scanInProgress) {
      this.aborted = true;
      logger.info('Vulnerability scan aborted');
    }
  }
}

module.exports = VulnerabilityScanner;
