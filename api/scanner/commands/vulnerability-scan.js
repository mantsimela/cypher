const VulnerabilityScanner = require('../lib/scanners/vulnerability-scanner');
const reporter = require('../lib/utils/reporter');
const validator = require('../lib/utils/validator');
const logger = require('../lib/utils/logger');

// ANSI color codes to replace chalk
const colors = {
  blue: (text) => `\x1b[34m${text}\x1b[0m`,
  yellow: (text) => `\x1b[33m${text}\x1b[0m`,
  red: (text) => `\x1b[31m${text}\x1b[0m`,
  green: (text) => `\x1b[32m${text}\x1b[0m`,
  cyan: (text) => `\x1b[36m${text}\x1b[0m`,
  gray: (text) => `\x1b[90m${text}\x1b[0m`,
  white: (text) => `\x1b[37m${text}\x1b[0m`
};

// Extended color functions
colors.red.bold = (text) => `\x1b[1m\x1b[31m${text}\x1b[0m`;

/**
 * Handle vulnerability scan command
 * @param {string} target - Target to scan
 * @param {Object} options - Command options
 */
async function vulnerabilityScan(target, options) {
  try {
    // Validate target
    if (!validator.isValidTarget(target)) {
      logger.error(`Invalid target: ${target}`);
      process.exit(1);
    }
    
    // Parse and validate ports
    const ports = validator.parsePortsString(options.ports);
    if (!ports || ports.length === 0) {
      logger.error(`Invalid port specification: ${options.ports}`);
      process.exit(1);
    }
    
    // Parse and validate timeout
    const timeout = validator.parseTimeout(options.timeout, 10000);
    
    // Initialize scanner
    const scanner = new VulnerabilityScanner({
      timeout
    });
    
    // Set up event listeners
    scanner.on('progress', (data) => {
      if (data.phase === 'port-scan') {
        process.stdout.write(`\r${colors.blue(`Port scanning... [${data.percent}%]`)} - ${data.scanned} of ${data.total} ports checked`);
      } else if (data.phase === 'vulnerability-check') {
        process.stdout.write(`\r${colors.blue(`Vulnerability check... [${Math.round((data.current / data.total) * 100)}%]`)} - ${data.check}`);
      }
    });
    
    // Handle graceful termination
    process.on('SIGINT', () => {
      console.log(colors.yellow('\nScan interrupted. Shutting down...'));
      scanner.abort();
      process.exit(0);
    });
    
    // Display scan information
    console.log(colors.blue('Starting Vulnerability Scan'));
    console.log(`Target:       ${colors.yellow(target)}`);
    console.log(`Ports:        ${colors.yellow(options.ports)}`);
    console.log(`Checks:       ${colors.yellow(options.checks)}`);
    console.log(`Timeout:      ${colors.yellow(timeout)}ms`);
    console.log(colors.blue('-'.repeat(60)));
    
    // Start the scan
    const startTime = Date.now();
    const results = await scanner.scan(target, {
      ports,
      checks: options.checks
    });
    const endTime = Date.now();
    const duration = (endTime - startTime) / 1000;
    
    // Clear the progress line
    process.stdout.write('\r' + ' '.repeat(100) + '\r');
    
    // Display scan results summary
    console.log(colors.blue('\nVulnerability Scan Results'));
    console.log(`${colors.yellow('Target:')} ${target}`);
    console.log(`${colors.yellow('Scan Duration:')} ${duration.toFixed(2)} seconds`);
    console.log(`${colors.yellow('Open Ports:')} ${results.openPorts.length}`);
    console.log(`${colors.yellow('Vulnerabilities Found:')} ${results.vulnerabilities.length}`);
    if (results.stats) {
      console.log(`  ${colors.red('High:')} ${results.stats.high}`);
      console.log(`  ${colors.yellow('Medium:')} ${results.stats.medium}`);
      console.log(`  ${colors.blue('Low:')} ${results.stats.low}`);
      console.log(`  ${colors.gray('Info:')} ${results.stats.info}`);
    }
    console.log(colors.blue('-'.repeat(60)));
    
    // Display open ports
    if (results.openPorts.length > 0) {
      console.log(colors.blue('\nOpen Ports:'));
      console.log(`${colors.cyan('PORT')}  ${colors.cyan('STATE')}  ${colors.cyan('SERVICE')}`);
      
      results.openPorts.forEach(result => {
        console.log(`${colors.green(result.port.toString().padEnd(5))} ${colors.green('open'.padEnd(6))} ${result.service}`);
      });
    }
    
    // Display vulnerabilities by severity
    if (results.vulnerabilities.length > 0) {
      // Group by severity
      const severities = ['critical', 'high', 'medium', 'low', 'info'];
      
      console.log(colors.blue('\nVulnerabilities:'));
      
      for (const severity of severities) {
        const vulnsForSeverity = results.vulnerabilities.filter(v => v.severity === severity);
        
        if (vulnsForSeverity.length > 0) {
          // Color code severity
          let colorFn;
          switch (severity) {
            case 'critical':
              colorFn = colors.red.bold;
              break;
            case 'high':
              colorFn = colors.red;
              break;
            case 'medium':
              colorFn = colors.yellow;
              break;
            case 'low':
              colorFn = colors.blue;
              break;
            case 'info':
              colorFn = colors.gray;
              break;
            default:
              colorFn = colors.white;
          }
          
          console.log(`\n${colorFn(`${severity.toUpperCase()} Severity (${vulnsForSeverity.length})`)}`);
          console.log(colorFn('-'.repeat(severity.length + 18 + vulnsForSeverity.length.toString().length)));
          
          vulnsForSeverity.forEach((vuln, index) => {
            console.log(`${index + 1}. ${colorFn(vuln.name)}${vuln.port ? ` (Port ${vuln.port})` : ''}`);
            console.log(`   ${vuln.description}`);
            
            // Display relevant details if available
            if (vuln.details) {
              const details = Object.entries(vuln.details)
                .filter(([key, value]) => !key.includes('recommendation') && value !== null && value !== undefined)
                .map(([key, value]) => {
                  if (typeof value === 'object') {
                    return `${key}: ${JSON.stringify(value)}`;
                  }
                  return `${key}: ${value}`;
                });
              
              if (details.length > 0) {
                console.log(`   Details: ${details.join(', ')}`);
              }
              
              // Show recommendation separately if available
              if (vuln.details.recommendation) {
                console.log(`   Recommendation: ${vuln.details.recommendation}`);
              }
            }
            
            console.log(''); // Add a blank line between vulnerabilities
          });
        }
      }
    } else {
      console.log(colors.green('\nNo vulnerabilities found.'));
    }
    
    // Output results to file if requested
    if (options.output) {
      // Prepare target host information
      const targetHost = target;
      
      await reporter.writeResults(results, {
        filename: options.output,
        format: options.format,
        scanType: 'vulnerability-scan',
        comprehensive: options.comprehensive === 'true',
        scanTitle: options.scanTitle || `Vulnerability Assessment - ${target} - ${new Date().toLocaleDateString()}`,
        targetHosts: [targetHost],
        excludedHosts: []
      });
      console.log(colors.green(`\nResults written to ${options.output}`));
    }
    
  } catch (error) {
    logger.error(`Vulnerability scan error: ${error.message}`);
    process.exit(1);
  }
}

module.exports = vulnerabilityScan;
