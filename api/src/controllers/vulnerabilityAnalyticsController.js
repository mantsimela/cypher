const vulnerabilityAnalyticsService = require('../services/vulnerabilityAnalyticsService');
const { validateRequest } = require('../middleware/validation');
const { z } = require('zod');

// Validation schemas
const costAnalysisSchema = z.object({
  vulnerabilityId: z.number().int().positive(),
  costModelId: z.number().int().positive().optional(),
  directCosts: z.number().min(0),
  indirectCosts: z.number().min(0),
  remediationCosts: z.number().min(0),
  timeCosts: z.number().min(0).optional(),
  totalCost: z.number().min(0),
  costBenefitRatio: z.number().optional(),
  roiPercentage: z.number().optional(),
  dataFactors: z.object({}).optional(),
  aiConfidence: z.number().min(0).max(100).optional(),
  calculatedBy: z.string().optional(),
});

const costFactorSchema = z.object({
  name: z.string().min(1).max(255),
  description: z.string().min(1),
  weight: z.number().min(0),
  category: z.string().min(1),
  minValue: z.number().min(0),
  maxValue: z.number().min(0),
  defaultValue: z.number().min(0),
  isActive: z.boolean().optional(),
});

const costModelSchema = z.object({
  name: z.string().min(1).max(255),
  description: z.string().min(1),
  formula: z.string().min(1),
  parameters: z.object({}).optional(),
  isDefault: z.boolean().optional(),
});

const patchSchema = z.object({
  vulnerabilityId: z.number().int().positive(),
  patchId: z.number().int().positive(),
  effectiveness: z.enum(['complete', 'partial', 'minimal']).optional(),
  notes: z.string().optional(),
});

class VulnerabilityAnalyticsController {
  // ===== COST ANALYSIS ENDPOINTS =====
  
  async getCostAnalysis(req, res) {
    try {
      const filters = {
        vulnerabilityId: req.query.vulnerabilityId ? parseInt(req.query.vulnerabilityId) : undefined,
        costModelId: req.query.costModelId ? parseInt(req.query.costModelId) : undefined,
        minTotalCost: req.query.minTotalCost ? parseFloat(req.query.minTotalCost) : undefined,
        maxTotalCost: req.query.maxTotalCost ? parseFloat(req.query.maxTotalCost) : undefined,
        sortBy: req.query.sortBy,
        sortOrder: req.query.sortOrder,
        limit: req.query.limit,
        offset: req.query.offset,
      };
      
      const analyses = await vulnerabilityAnalyticsService.getCostAnalysis(filters);
      
      res.json({
        success: true,
        data: analyses,
        count: analyses.length,
      });
    } catch (error) {
      console.error('Error getting cost analysis:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to retrieve cost analysis',
        error: error.message,
      });
    }
  }
  
  async createCostAnalysis(req, res) {
    try {
      const validatedData = costAnalysisSchema.parse(req.body);
      const analysis = await vulnerabilityAnalyticsService.createCostAnalysis(validatedData);
      
      res.status(201).json({
        success: true,
        data: analysis,
        message: 'Cost analysis created successfully',
      });
    } catch (error) {
      console.error('Error creating cost analysis:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to create cost analysis',
        error: error.message,
      });
    }
  }
  
  async updateCostAnalysis(req, res) {
    try {
      const { id } = req.params;
      const validatedData = costAnalysisSchema.partial().parse(req.body);
      
      const analysis = await vulnerabilityAnalyticsService.updateCostAnalysis(parseInt(id), validatedData);
      
      if (!analysis) {
        return res.status(404).json({
          success: false,
          message: 'Cost analysis not found',
        });
      }
      
      res.json({
        success: true,
        data: analysis,
        message: 'Cost analysis updated successfully',
      });
    } catch (error) {
      console.error('Error updating cost analysis:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to update cost analysis',
        error: error.message,
      });
    }
  }
  
  async deleteCostAnalysis(req, res) {
    try {
      const { id } = req.params;
      await vulnerabilityAnalyticsService.deleteCostAnalysis(parseInt(id));
      
      res.json({
        success: true,
        message: 'Cost analysis deleted successfully',
      });
    } catch (error) {
      console.error('Error deleting cost analysis:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to delete cost analysis',
        error: error.message,
      });
    }
  }
  
  // ===== COST FACTORS ENDPOINTS =====
  
  async getCostFactors(req, res) {
    try {
      const filters = {
        category: req.query.category,
        isActive: req.query.isActive !== undefined ? req.query.isActive === 'true' : undefined,
        search: req.query.search,
        sortBy: req.query.sortBy,
        sortOrder: req.query.sortOrder,
      };
      
      const factors = await vulnerabilityAnalyticsService.getCostFactors(filters);
      
      res.json({
        success: true,
        data: factors,
        count: factors.length,
      });
    } catch (error) {
      console.error('Error getting cost factors:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to retrieve cost factors',
        error: error.message,
      });
    }
  }
  
  async createCostFactor(req, res) {
    try {
      const validatedData = costFactorSchema.parse(req.body);
      const factor = await vulnerabilityAnalyticsService.createCostFactor(validatedData);
      
      res.status(201).json({
        success: true,
        data: factor,
        message: 'Cost factor created successfully',
      });
    } catch (error) {
      console.error('Error creating cost factor:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to create cost factor',
        error: error.message,
      });
    }
  }
  
  async updateCostFactor(req, res) {
    try {
      const { id } = req.params;
      const validatedData = costFactorSchema.partial().parse(req.body);
      
      const factor = await vulnerabilityAnalyticsService.updateCostFactor(parseInt(id), validatedData);
      
      if (!factor) {
        return res.status(404).json({
          success: false,
          message: 'Cost factor not found',
        });
      }
      
      res.json({
        success: true,
        data: factor,
        message: 'Cost factor updated successfully',
      });
    } catch (error) {
      console.error('Error updating cost factor:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to update cost factor',
        error: error.message,
      });
    }
  }
  
  async deleteCostFactor(req, res) {
    try {
      const { id } = req.params;
      await vulnerabilityAnalyticsService.deleteCostFactor(parseInt(id));
      
      res.json({
        success: true,
        message: 'Cost factor deleted successfully',
      });
    } catch (error) {
      console.error('Error deleting cost factor:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to delete cost factor',
        error: error.message,
      });
    }
  }
  
  // ===== COST MODELS ENDPOINTS =====
  
  async getCostModels(req, res) {
    try {
      const filters = {
        isDefault: req.query.isDefault !== undefined ? req.query.isDefault === 'true' : undefined,
        search: req.query.search,
        sortBy: req.query.sortBy,
        sortOrder: req.query.sortOrder,
      };
      
      const models = await vulnerabilityAnalyticsService.getCostModels(filters);
      
      res.json({
        success: true,
        data: models,
        count: models.length,
      });
    } catch (error) {
      console.error('Error getting cost models:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to retrieve cost models',
        error: error.message,
      });
    }
  }
  
  async createCostModel(req, res) {
    try {
      const validatedData = costModelSchema.parse(req.body);
      const model = await vulnerabilityAnalyticsService.createCostModel(validatedData);
      
      res.status(201).json({
        success: true,
        data: model,
        message: 'Cost model created successfully',
      });
    } catch (error) {
      console.error('Error creating cost model:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to create cost model',
        error: error.message,
      });
    }
  }
  
  async updateCostModel(req, res) {
    try {
      const { id } = req.params;
      const validatedData = costModelSchema.partial().parse(req.body);
      
      const model = await vulnerabilityAnalyticsService.updateCostModel(parseInt(id), validatedData);
      
      if (!model) {
        return res.status(404).json({
          success: false,
          message: 'Cost model not found',
        });
      }
      
      res.json({
        success: true,
        data: model,
        message: 'Cost model updated successfully',
      });
    } catch (error) {
      console.error('Error updating cost model:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to update cost model',
        error: error.message,
      });
    }
  }
  
  async deleteCostModel(req, res) {
    try {
      const { id } = req.params;
      await vulnerabilityAnalyticsService.deleteCostModel(parseInt(id));
      
      res.json({
        success: true,
        message: 'Cost model deleted successfully',
      });
    } catch (error) {
      console.error('Error deleting cost model:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to delete cost model',
        error: error.message,
      });
    }
  }
  
  // ===== ANALYTICS ENDPOINTS =====
  
  async getCostSummary(req, res) {
    try {
      const summary = await vulnerabilityAnalyticsService.getCostSummary();
      
      res.json({
        success: true,
        data: summary,
      });
    } catch (error) {
      console.error('Error getting cost summary:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to retrieve cost summary',
        error: error.message,
      });
    }
  }
  
  async getVulnerabilityWithCostAnalysis(req, res) {
    try {
      const { vulnerabilityId } = req.params;
      const result = await vulnerabilityAnalyticsService.getVulnerabilityWithCostAnalysis(parseInt(vulnerabilityId));
      
      res.json({
        success: true,
        data: result,
      });
    } catch (error) {
      console.error('Error getting vulnerability with cost analysis:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to retrieve vulnerability with cost analysis',
        error: error.message,
      });
    }
  }
}

module.exports = new VulnerabilityAnalyticsController();
