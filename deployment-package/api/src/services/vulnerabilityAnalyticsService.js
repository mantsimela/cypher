const { db, client } = require('../db');
const {
  vulnerabilityCostAnalysis,
  vulnerabilityCostFactors,
  vulnerabilityCostHistory,
  vulnerabilityCostModels,
  vulnerabilityPatches,
  vulnerabilityPoams,
  vulnerabilities
} = require('../db/schema');
const { eq, desc, asc, and, or, gte, lte, like, count, sum, avg } = require('drizzle-orm');

class VulnerabilityAnalyticsService {
  // ===== VULNERABILITY COST ANALYSIS =====
  
  async getCostAnalysis(filters = {}) {
    try {
      let query = db.select().from(vulnerabilityCostAnalysis);
      
      if (filters.vulnerabilityId) {
        query = query.where(eq(vulnerabilityCostAnalysis.vulnerabilityId, filters.vulnerabilityId));
      }
      
      if (filters.costModelId) {
        query = query.where(eq(vulnerabilityCostAnalysis.costModelId, filters.costModelId));
      }
      
      if (filters.minTotalCost) {
        query = query.where(gte(vulnerabilityCostAnalysis.totalCost, filters.minTotalCost));
      }
      
      if (filters.maxTotalCost) {
        query = query.where(lte(vulnerabilityCostAnalysis.totalCost, filters.maxTotalCost));
      }
      
      // Sorting
      const sortBy = filters.sortBy || 'analysisDate';
      const sortOrder = filters.sortOrder || 'desc';
      const sortColumn = vulnerabilityCostAnalysis[sortBy] || vulnerabilityCostAnalysis.analysisDate;
      query = query.orderBy(sortOrder === 'asc' ? asc(sortColumn) : desc(sortColumn));
      
      // Pagination
      if (filters.limit) {
        query = query.limit(parseInt(filters.limit));
      }
      if (filters.offset) {
        query = query.offset(parseInt(filters.offset));
      }
      
      return await query;
    } catch (error) {
      throw new Error(`Failed to get cost analysis: ${error.message}`);
    }
  }
  
  async createCostAnalysis(data) {
    try {
      const [result] = await db.insert(vulnerabilityCostAnalysis).values(data).returning();
      return result;
    } catch (error) {
      throw new Error(`Failed to create cost analysis: ${error.message}`);
    }
  }
  
  async updateCostAnalysis(id, data) {
    try {
      const [result] = await db
        .update(vulnerabilityCostAnalysis)
        .set(data)
        .where(eq(vulnerabilityCostAnalysis.id, id))
        .returning();
      return result;
    } catch (error) {
      throw new Error(`Failed to update cost analysis: ${error.message}`);
    }
  }
  
  async deleteCostAnalysis(id) {
    try {
      await db.delete(vulnerabilityCostAnalysis).where(eq(vulnerabilityCostAnalysis.id, id));
      return { success: true };
    } catch (error) {
      throw new Error(`Failed to delete cost analysis: ${error.message}`);
    }
  }
  
  // ===== VULNERABILITY COST FACTORS =====
  
  async getCostFactors(filters = {}) {
    try {
      let query = db.select().from(vulnerabilityCostFactors);
      
      if (filters.category) {
        query = query.where(eq(vulnerabilityCostFactors.category, filters.category));
      }
      
      if (filters.isActive !== undefined) {
        query = query.where(eq(vulnerabilityCostFactors.isActive, filters.isActive));
      }
      
      if (filters.search) {
        query = query.where(
          or(
            like(vulnerabilityCostFactors.name, `%${filters.search}%`),
            like(vulnerabilityCostFactors.description, `%${filters.search}%`)
          )
        );
      }
      
      // Sorting
      const sortBy = filters.sortBy || 'name';
      const sortOrder = filters.sortOrder || 'asc';
      const sortColumn = vulnerabilityCostFactors[sortBy] || vulnerabilityCostFactors.name;
      query = query.orderBy(sortOrder === 'asc' ? asc(sortColumn) : desc(sortColumn));
      
      return await query;
    } catch (error) {
      throw new Error(`Failed to get cost factors: ${error.message}`);
    }
  }
  
  async createCostFactor(data) {
    try {
      const [result] = await db.insert(vulnerabilityCostFactors).values(data).returning();
      return result;
    } catch (error) {
      throw new Error(`Failed to create cost factor: ${error.message}`);
    }
  }
  
  async updateCostFactor(id, data) {
    try {
      const [result] = await db
        .update(vulnerabilityCostFactors)
        .set(data)
        .where(eq(vulnerabilityCostFactors.id, id))
        .returning();
      return result;
    } catch (error) {
      throw new Error(`Failed to update cost factor: ${error.message}`);
    }
  }
  
  async deleteCostFactor(id) {
    try {
      await db.delete(vulnerabilityCostFactors).where(eq(vulnerabilityCostFactors.id, id));
      return { success: true };
    } catch (error) {
      throw new Error(`Failed to delete cost factor: ${error.message}`);
    }
  }
  
  // ===== VULNERABILITY COST MODELS =====
  
  async getCostModels(filters = {}) {
    try {
      let query = db.select().from(vulnerabilityCostModels);
      
      if (filters.isDefault !== undefined) {
        query = query.where(eq(vulnerabilityCostModels.isDefault, filters.isDefault));
      }
      
      if (filters.search) {
        query = query.where(
          or(
            like(vulnerabilityCostModels.name, `%${filters.search}%`),
            like(vulnerabilityCostModels.description, `%${filters.search}%`)
          )
        );
      }
      
      // Sorting
      const sortBy = filters.sortBy || 'name';
      const sortOrder = filters.sortOrder || 'asc';
      const sortColumn = vulnerabilityCostModels[sortBy] || vulnerabilityCostModels.name;
      query = query.orderBy(sortOrder === 'asc' ? asc(sortColumn) : desc(sortColumn));
      
      return await query;
    } catch (error) {
      throw new Error(`Failed to get cost models: ${error.message}`);
    }
  }
  
  async createCostModel(data) {
    try {
      const [result] = await db.insert(vulnerabilityCostModels).values(data).returning();
      return result;
    } catch (error) {
      throw new Error(`Failed to create cost model: ${error.message}`);
    }
  }
  
  async updateCostModel(id, data) {
    try {
      const [result] = await db
        .update(vulnerabilityCostModels)
        .set(data)
        .where(eq(vulnerabilityCostModels.id, id))
        .returning();
      return result;
    } catch (error) {
      throw new Error(`Failed to update cost model: ${error.message}`);
    }
  }
  
  async deleteCostModel(id) {
    try {
      await db.delete(vulnerabilityCostModels).where(eq(vulnerabilityCostModels.id, id));
      return { success: true };
    } catch (error) {
      throw new Error(`Failed to delete cost model: ${error.message}`);
    }
  }
  
  // ===== VULNERABILITY PATCHES =====
  
  async getPatches(filters = {}) {
    try {
      let query = db.select().from(vulnerabilityPatches);
      
      if (filters.vulnerabilityId) {
        query = query.where(eq(vulnerabilityPatches.vulnerabilityId, filters.vulnerabilityId));
      }
      
      if (filters.patchId) {
        query = query.where(eq(vulnerabilityPatches.patchId, filters.patchId));
      }
      
      if (filters.effectiveness) {
        query = query.where(eq(vulnerabilityPatches.effectiveness, filters.effectiveness));
      }
      
      return await query;
    } catch (error) {
      throw new Error(`Failed to get patches: ${error.message}`);
    }
  }
  
  async createPatch(data) {
    try {
      const [result] = await db.insert(vulnerabilityPatches).values(data).returning();
      return result;
    } catch (error) {
      throw new Error(`Failed to create patch: ${error.message}`);
    }
  }
  
  async updatePatch(id, data) {
    try {
      const [result] = await db
        .update(vulnerabilityPatches)
        .set(data)
        .where(eq(vulnerabilityPatches.id, id))
        .returning();
      return result;
    } catch (error) {
      throw new Error(`Failed to update patch: ${error.message}`);
    }
  }
  
  async deletePatch(id) {
    try {
      await db.delete(vulnerabilityPatches).where(eq(vulnerabilityPatches.id, id));
      return { success: true };
    } catch (error) {
      throw new Error(`Failed to delete patch: ${error.message}`);
    }
  }
  
  // ===== ANALYTICS & REPORTING =====
  
  async getCostSummary(filters = {}) {
    try {
      const result = await db
        .select({
          totalAnalyses: count(vulnerabilityCostAnalysis.id),
          totalCost: sum(vulnerabilityCostAnalysis.totalCost),
          avgCost: avg(vulnerabilityCostAnalysis.totalCost),
          avgDirectCosts: avg(vulnerabilityCostAnalysis.directCosts),
          avgIndirectCosts: avg(vulnerabilityCostAnalysis.indirectCosts),
          avgRemediationCosts: avg(vulnerabilityCostAnalysis.remediationCosts),
        })
        .from(vulnerabilityCostAnalysis);
      
      return result[0];
    } catch (error) {
      throw new Error(`Failed to get cost summary: ${error.message}`);
    }
  }
  
  async getVulnerabilityWithCostAnalysis(vulnerabilityId) {
    try {
      const result = await db
        .select({
          vulnerability: vulnerabilities,
          costAnalysis: vulnerabilityCostAnalysis,
        })
        .from(vulnerabilities)
        .leftJoin(
          vulnerabilityCostAnalysis,
          eq(vulnerabilities.id, vulnerabilityCostAnalysis.vulnerabilityId)
        )
        .where(eq(vulnerabilities.id, vulnerabilityId));
      
      return result;
    } catch (error) {
      throw new Error(`Failed to get vulnerability with cost analysis: ${error.message}`);
    }
  }
}

module.exports = new VulnerabilityAnalyticsService();
